<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egg Yolk Liquid Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .header {
            text-align: center;
            padding: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            margin: 10px 0 0 0;
            font-size: 1.1em;
            opacity: 0.8;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #yolkCanvas {
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.2);
            cursor: crosshair;
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 20px;
            color: #fff;
            min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group h3 {
            margin: 0 0 15px 0;
            color: #ffd700;
            font-size: 1.1em;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
            padding-bottom: 5px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .control-row label {
            font-size: 0.9em;
            color: #ccc;
            min-width: 80px;
        }

        .control-row input[type="range"] {
            flex: 1;
            margin: 0 15px;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }

        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .control-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .control-row select {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 5px 10px;
            outline: none;
            cursor: pointer;
        }

        .control-row select:focus {
            border-color: #ffd700;
        }

        .value-display {
            font-size: 0.8em;
            color: #ffd700;
            min-width: 50px;
            text-align: right;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 15px;
            color: #fff;
            font-size: 0.9em;
            max-width: 300px;
        }

        .info-panel h4 {
            margin: 0 0 10px 0;
            color: #ffd700;
        }

        .info-panel p {
            margin: 5px 0;
            opacity: 0.8;
        }

        .touch-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 215, 0, 0.6);
            font-size: 0.9em;
            text-align: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .touch-indicator.show {
            opacity: 1;
        }

        @media (max-width: 768px) {
            .controls {
                position: relative;
                top: auto;
                right: auto;
                margin: 20px;
                min-width: auto;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ¥š Egg Yolk Liquid</h1>
        <p>Interactive 3D Yolk Visualization with Liquid Physics</p>
    </div>

    <div class="canvas-container">
        <canvas id="yolkCanvas" width="800" height="600"></canvas>
        
        <div class="touch-indicator" id="touchIndicator">
            Touch the yolk to interact!<br>
            <small>Only front half is interactive</small>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <h3>ðŸŽ¨ Yolk Properties</h3>
            <div class="control-row">
                <label>Particle Count:</label>
                <input type="range" id="particleCount" min="1000" max="8000" value="3000" step="500">
                <span class="value-display" id="particleCountValue">3000</span>
            </div>
            <div class="control-row">
                <label>Distribution:</label>
                <select id="distribution">
                    <option value="volume">Volume</option>
                    <option value="surface">Surface</option>
                    <option value="mixed">Mixed</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <h3>ðŸ’§ Liquid Physics</h3>
            <div class="control-row">
                <label>Viscosity:</label>
                <input type="range" id="viscosity" min="0.1" max="2.0" value="0.8" step="0.1">
                <span class="value-display" id="viscosityValue">0.8</span>
            </div>
            <div class="control-row">
                <label>Random Movement:</label>
                <input type="range" id="randomMovement" min="0" max="2.0" value="0.5" step="0.1">
                <span class="value-display" id="randomMovementValue">0.5</span>
            </div>
            <div class="control-row">
                <label>Path Length:</label>
                <input type="range" id="pathLength" min="0.1" max="3.0" value="1.0" step="0.1">
                <span class="value-display" id="pathLengthValue">1.0</span>
            </div>
            <div class="control-row">
                <label>Particle Speed:</label>
                <input type="range" id="particleSpeed" min="0.1" max="3.0" value="1.0" step="0.1">
                <span class="value-display" id="particleSpeedValue">1.0</span>
            </div>
            <div class="control-row">
                <label>Touch Strength:</label>
                <input type="range" id="touchStrength" min="0.5" max="3.0" value="1.5" step="0.1">
                <span class="value-display" id="touchStrengthValue">1.5</span>
            </div>
        </div>

        <div class="control-group">
            <h3>ðŸ”„ Animation</h3>
            <div class="control-row">
                <label>Rotation Speed:</label>
                <input type="range" id="rotationSpeed" min="0" max="2.0" value="0.5" step="0.1">
                <span class="value-display" id="rotationSpeedValue">0.5</span>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <h4>ðŸŽ¯ How to Use</h4>
        <p><strong>Touch/Click:</strong> Push particles away from touch point</p>
        <p><strong>Drag:</strong> Rotate the yolk manually</p>
        <p><strong>Viscosity:</strong> Higher = firmer yolk (like hard-boiled)</p>
        <p><strong>Particles:</strong> Adjust count and distribution</p>
    </div>

    <script>
        class EggYolkVisualizer {
            constructor() {
                this.canvas = document.getElementById('yolkCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.touchIndicator = document.getElementById('touchIndicator');
                
                // Yolk settings
                this.settings = {
                    particleCount: 3000,
                    distribution: 'volume',
                    viscosity: 0.8,
                    randomMovement: 0.5,
                    pathLength: 1.0,      // How far particles can travel from base position
                    particleSpeed: 1.0,    // How fast particles move
                    touchStrength: 1.5,
                    rotationSpeed: 0.5,
                    sphereRadius: 175,
                    particleSize: 2
                };
                
                this.particles = [];
                this.time = 0;
                this.rotationX = 0;
                this.rotationY = 0;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.animationId = null;
                
                this.setupEventListeners();
                this.initParticleSystem();
                this.startAnimation();
                this.updateDisplay();
            }
            
            setupEventListeners() {
                // Touch/click events
                this.canvas.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('mouseup', () => this.handlePointerUp());
                this.canvas.addEventListener('mouseleave', () => this.handlePointerUp());
                
                // Touch events
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handlePointerDown(e.touches[0]);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handlePointerMove(e.touches[0]);
                });
                this.canvas.addEventListener('touchend', () => this.handlePointerUp());
                
                // Control updates
                document.getElementById('particleCount').addEventListener('input', (e) => {
                    this.settings.particleCount = parseInt(e.target.value);
                    this.updateDisplay();
                    this.initParticleSystem();
                });
                
                document.getElementById('distribution').addEventListener('change', (e) => {
                    this.settings.distribution = e.target.value;
                    this.initParticleSystem();
                });
                
                document.getElementById('viscosity').addEventListener('input', (e) => {
                    this.settings.viscosity = parseFloat(e.target.value);
                    this.updateDisplay();
                    this.mapViscosityToPhysics(); // Update physics based on new viscosity
                });
                
                document.getElementById('randomMovement').addEventListener('input', (e) => {
                    this.settings.randomMovement = parseFloat(e.target.value);
                    this.updateDisplay();
                });
                
                document.getElementById('pathLength').addEventListener('input', (e) => {
                    this.settings.pathLength = parseFloat(e.target.value);
                    this.updateDisplay();
                });

                document.getElementById('particleSpeed').addEventListener('input', (e) => {
                    this.settings.particleSpeed = parseFloat(e.target.value);
                    this.updateDisplay();
                });
                
                document.getElementById('touchStrength').addEventListener('input', (e) => {
                    this.settings.touchStrength = parseFloat(e.target.value);
                    this.updateDisplay();
                });
                
                document.getElementById('rotationSpeed').addEventListener('input', (e) => {
                    this.settings.rotationSpeed = parseFloat(e.target.value);
                    this.updateDisplay();
                });
                
                // Window resize
                window.addEventListener('resize', () => this.handleResize());
                this.handleResize();
            }
            
            handleResize() {
                const container = this.canvas.parentElement;
                const maxWidth = Math.min(800, container.clientWidth - 40);
                const maxHeight = Math.min(600, container.clientHeight - 40);
                
                this.canvas.width = maxWidth;
                this.canvas.height = maxHeight;
                
                // Adjust sphere radius based on canvas size
                this.settings.sphereRadius = Math.min(maxWidth, maxHeight) * 0.35;
            }
            
            initParticleSystem() {
                this.particles = [];
                const count = this.settings.particleCount;
                
                for (let i = 0; i < count; i++) {
                    let x, y, z;
                    
                    switch (this.settings.distribution) {
                        case 'volume':
                            // Uniform distribution in volume
                            const r = this.settings.sphereRadius * Math.pow(Math.random(), 1/3);
                            const theta = Math.acos(2 * Math.random() - 1);
                            const phi = 2 * Math.PI * Math.random();
                            
                            x = r * Math.sin(theta) * Math.cos(phi);
                            y = r * Math.sin(theta) * Math.sin(phi);
                            z = r * Math.cos(theta);
                            break;
                            
                        case 'surface':
                            // Surface distribution
                            const radius = this.settings.sphereRadius;
                            const surfaceTheta = Math.acos(2 * Math.random() - 1);
                            const surfacePhi = 2 * Math.PI * Math.random();
                            
                            x = radius * Math.sin(surfaceTheta) * Math.cos(surfacePhi);
                            y = radius * Math.sin(surfaceTheta) * Math.sin(surfacePhi);
                            z = radius * Math.cos(surfaceTheta);
                            break;
                            
                        case 'mixed':
                            // 70% volume, 30% surface
                            if (Math.random() < 0.7) {
                                const mixedR = this.settings.sphereRadius * Math.pow(Math.random(), 1/3);
                                const mixedTheta = Math.acos(2 * Math.random() - 1);
                                const mixedPhi = 2 * Math.PI * Math.random();
                                
                                x = mixedR * Math.sin(mixedTheta) * Math.cos(mixedPhi);
                                y = mixedR * Math.sin(mixedTheta) * Math.sin(mixedPhi);
                                z = mixedR * Math.cos(mixedTheta);
                            } else {
                                const mixedRadius = this.settings.sphereRadius;
                                const mixedSurfaceTheta = Math.acos(2 * Math.random() - 1);
                                const mixedSurfacePhi = 2 * Math.PI * Math.random();
                                
                                x = mixedRadius * Math.sin(mixedSurfaceTheta) * Math.cos(mixedSurfacePhi);
                                y = mixedRadius * Math.sin(mixedSurfaceTheta) * Math.sin(mixedSurfacePhi);
                                z = mixedRadius * Math.cos(mixedSurfaceTheta);
                            }
                            break;
                    }
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        z: z,
                        baseX: x,
                        baseY: y,
                        baseZ: z,
                        vx: 0,
                        vy: 0,
                        vz: 0,
                        screenX: 0,
                        screenY: 0
                    });
                }
                this.mapViscosityToPhysics(); // Initialize physics after particles are set
            }
            
            handlePointerDown(e) {
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
                
                // Apply touch impulse
                this.applyTouchImpulse(e.clientX, e.clientY);
                
                // Show touch indicator
                this.touchIndicator.classList.add('show');
                setTimeout(() => this.touchIndicator.classList.remove('show'), 2000);
            }
            
            handlePointerMove(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.rotationY += deltaX * 0.01;
                this.rotationX += deltaY * 0.01;
                
                // Clamp rotation
                this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }
            
            handlePointerUp() {
                this.isDragging = false;
            }
            
            applyTouchImpulse(mouseX, mouseY) {
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = mouseX - rect.left;
                const canvasY = mouseY - rect.top;
                
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Calculate distance from center
                const distanceFromCenter = Math.sqrt(
                    Math.pow(canvasX - centerX, 2) + 
                    Math.pow(canvasY - centerY, 2)
                );
                
                // Only allow interaction if click is within sphere bounds
                const sphereScreenRadius = this.settings.sphereRadius * 0.8;
                
                if (distanceFromCenter > sphereScreenRadius) {
                    return; // Click is outside sphere
                }
                
                // Project onto sphere surface (front surface only)
                const normalizedX = (canvasX - centerX) / sphereScreenRadius;
                const normalizedY = (centerY - canvasY) / sphereScreenRadius;
                
                // Only allow interaction on front half (positive Z)
                const z = this.settings.sphereRadius * 0.5; // Front half
                const x = normalizedX * this.settings.sphereRadius;
                const y = normalizedY * this.settings.sphereRadius;
                
                const touchPoint = { x, y, z };
                
                // Apply impulse to nearby particles
                this.particles.forEach(particle => {
                    const distance = Math.sqrt(
                        Math.pow(particle.x - touchPoint.x, 2) + 
                        Math.pow(particle.y - touchPoint.y, 2) + 
                        Math.pow(particle.z - touchPoint.z, 2)
                    );
                    
                    const influenceRadius = this.settings.sphereRadius * 0.4;
                    if (distance > influenceRadius) return;
                    
                    // Calculate weight based on distance
                    const weight = 1 - (distance / influenceRadius);
                    const impulse = this.settings.touchStrength * weight * weight;
                    
                    // Push particles away from touch point (into perspective)
                    const dirX = particle.x - touchPoint.x;
                    const dirY = particle.y - touchPoint.y;
                    const dirZ = particle.z - touchPoint.z;
                    
                    const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
                    if (length > 0) {
                        particle.vx += (dirX / length) * impulse;
                        particle.vy += (dirY / length) * impulse;
                        particle.vz += (dirZ / length) * impulse;
                    }
                });
            }
            
            updateParticles(deltaTime) {
                const springK = 0.1; // Spring constant
                const damping = 0.95 - (this.settings.viscosity * 0.1); // Viscosity affects damping
                
                // Apply path length control - affects how far particles can travel from base
                const pathLengthMultiplier = this.settings.pathLength || 1.0;
                
                // Apply particle speed control - affects velocity scaling
                const speedMultiplier = this.settings.particleSpeed || 1.0;
                
                this.particles.forEach(particle => {
                    // Calculate distance from base position
                    const distanceFromBase = Math.sqrt(
                        Math.pow(particle.x - particle.baseX, 2) + 
                        Math.pow(particle.y - particle.baseY, 2) + 
                        Math.pow(particle.z - particle.baseZ, 2)
                    );
                    
                    // Path length constraint: limit how far particles can travel from base
                    const maxDistanceFromBase = this.settings.sphereRadius * 0.3 * pathLengthMultiplier;
                    
                    if (distanceFromBase > maxDistanceFromBase) {
                        // Pull particle back towards base position
                        const scale = maxDistanceFromBase / distanceFromBase;
                        particle.x = particle.baseX + (particle.x - particle.baseX) * scale;
                        particle.y = particle.baseY + (particle.y - particle.baseY) * scale;
                        particle.z = particle.baseZ + (particle.z - particle.baseZ) * scale;
                        
                        // Reduce velocity when hitting path length limit
                        particle.vx *= 0.8;
                        particle.vy *= 0.8;
                        particle.vz *= 0.8;
                    }
                    
                    // Spring force back to base position
                    const springX = (particle.baseX - particle.x) * springK;
                    const springY = (particle.baseY - particle.y) * springK;
                    const springZ = (particle.baseZ - particle.z) * springK;
                    
                    // Random movement (affected by viscosity and path length)
                    const randomScale = this.settings.randomMovement * (1 - this.settings.viscosity * 0.3) * pathLengthMultiplier;
                    const randomX = (Math.random() - 0.5) * randomScale;
                    const randomY = (Math.random() - 0.5) * randomScale;
                    const randomZ = (Math.random() - 0.5) * randomScale;
                    
                    // Apply forces with speed multiplier
                    particle.vx += (springX + randomX) * speedMultiplier;
                    particle.vy += (springY + randomY) * speedMultiplier;
                    particle.vz += (springZ + randomZ) * speedMultiplier;
                    
                    // Apply damping (viscosity)
                    particle.vx *= damping;
                    particle.vy *= damping;
                    particle.vz *= damping;
                    
                    // Update position with speed multiplier
                    particle.x += particle.vx * speedMultiplier;
                    particle.y += particle.vy * speedMultiplier;
                    particle.z += particle.vz * speedMultiplier;
                    
                    // CRITICAL: Always keep particles within sphere bounds first
                    const distanceFromCenter = Math.sqrt(particle.x * particle.x + particle.y * particle.y + particle.z * particle.z);
                    if (distanceFromCenter > this.settings.sphereRadius) {
                        const scale = this.settings.sphereRadius / distanceFromCenter;
                        particle.x *= scale;
                        particle.y *= scale;
                        particle.z *= scale;
                        
                        // Bounce back with reduced velocity
                        particle.vx *= -0.5;
                        particle.vy *= -0.5;
                        particle.vz *= -0.5;
                    }
                    
                    // SECONDARY: Check path length constraint after sphere boundary
                    const finalDistanceFromBase = Math.sqrt(
                        Math.pow(particle.x - particle.baseX, 2) + 
                        Math.pow(particle.y - particle.baseY, 2) + 
                        Math.pow(particle.z - particle.baseZ, 2)
                    );
                    
                    if (finalDistanceFromBase > maxDistanceFromBase) {
                        // Pull particle back towards base position, but ensure it stays within sphere
                        const scale = maxDistanceFromBase / finalDistanceFromBase;
                        const newX = particle.baseX + (particle.x - particle.baseX) * scale;
                        const newY = particle.baseY + (particle.y - particle.baseY) * scale;
                        const newZ = particle.baseZ + (particle.z - particle.baseZ) * scale;
                        
                        // Check if new position would be outside sphere
                        const newDistanceFromCenter = Math.sqrt(newX * newX + newY * newY + newZ * newZ);
                        if (newDistanceFromCenter <= this.settings.sphereRadius) {
                            particle.x = newX;
                            particle.y = newY;
                            particle.z = newZ;
                        }
                        
                        // Reduce velocity when hitting path length limit
                        particle.vx *= 0.8;
                        particle.vy *= 0.8;
                        particle.vz *= 0.8;
                    }
                });
            }
            
            projectToScreen(particle) {
                // Apply rotations
                let x = particle.x;
                let y = particle.y;
                let z = particle.z;
                
                // Y rotation
                const cosY = Math.cos(this.rotationY);
                const sinY = Math.sin(this.rotationY);
                const tempX = x * cosY - z * sinY;
                const tempZ = x * sinY + z * cosY;
                x = tempX;
                z = tempZ;
                
                // X rotation
                const cosX = Math.cos(this.rotationX);
                const sinX = Math.sin(this.rotationX);
                const tempY = y * cosX - z * sinX;
                const tempZ2 = y * sinX + z * cosX;
                y = tempY;
                z = tempZ2;
                
                // Perspective projection
                const distance = 400;
                const scale = distance / (distance + z);
                
                particle.screenX = this.canvas.width / 2 + x * scale;
                particle.screenY = this.canvas.height / 2 + y * scale;
                
                return scale;
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Sort particles by Z for proper depth ordering
                const sortedParticles = [...this.particles].sort((a, b) => {
                    const scaleA = this.projectToScreen(a);
                    const scaleB = this.projectToScreen(b);
                    return scaleB - scaleA;
                });
                
                // Draw particles
                sortedParticles.forEach(particle => {
                    const scale = this.projectToScreen(particle);
                    
                    // Only draw particles that are visible
                    if (particle.screenX >= 0 && particle.screenX < this.canvas.width &&
                        particle.screenY >= 0 && particle.screenY < this.canvas.height) {
                        
                        const size = this.settings.particleSize * scale;
                        const alpha = 0.3 + (scale * 0.7);
                        
                        this.ctx.save();
                        this.ctx.globalAlpha = alpha;
                        this.ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                        this.ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                        this.ctx.shadowBlur = size * 2;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(particle.screenX, particle.screenY, size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                    }
                });
                
                // Draw sphere boundary (debug)
                this.ctx.save();
                this.ctx.strokeStyle = 'rgba(255, 215, 0, 0.2)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(this.canvas.width / 2, this.canvas.height / 2, this.settings.sphereRadius, 0, Math.PI * 2);
                this.ctx.stroke();
                this.ctx.restore();
            }
            
            animate(currentTime) {
                const deltaTime = 0.016; // Fixed time step for consistency
                this.time += deltaTime;
                
                // Auto-rotation
                if (!this.isDragging) {
                    this.rotationY += this.settings.rotationSpeed * 0.01;
                }
                
                // Update physics
                this.updateParticles(deltaTime);
                
                // Draw
                this.drawParticles();
                
                this.animationId = requestAnimationFrame((time) => this.animate(time));
            }
            
            startAnimation() {
                this.animate(0);
            }
            
            updateDisplay() {
                document.getElementById('particleCountValue').textContent = this.settings.particleCount;
                document.getElementById('viscosityValue').textContent = this.settings.viscosity.toFixed(1);
                document.getElementById('randomMovementValue').textContent = this.settings.randomMovement.toFixed(1);
                document.getElementById('pathLengthValue').textContent = this.settings.pathLength.toFixed(1);
                document.getElementById('particleSpeedValue').textContent = this.settings.particleSpeed.toFixed(1);
                document.getElementById('touchStrengthValue').textContent = this.settings.touchStrength.toFixed(1);
                document.getElementById('rotationSpeedValue').textContent = this.settings.rotationSpeed.toFixed(1);
            }

            mapViscosityToPhysics() {
                // Helper lerp function
                const L = (a, b, t) => a + (b - a) * t;
                // Exponential curve for nicer feel
                const E = t => Math.pow(t, 0.7);
                
                const vE = E(this.settings.viscosity);
                
                // Initialize physics object if it doesn't exist
                if (!this.physics) {
                    this.physics = {};
                }
                
                // Low viscosity (v=0): long path, lively, underdamped
                // High viscosity (v=1): short path, stiff, overdamped
                this.physics.springK = L(2.0, 7.0, vE);        // stiffer when hard
                this.physics.damping = L(1.1, 4.6, vE);        // more damping when hard
                this.physics.noiseStrength = L(0.8, 0.06, vE); // calmer when hard
                this.physics.flowSpeed = L(1.0, 0.15, vE);
                this.physics.pushStrength = L(70, 10, vE);     // weaker push when hard
                this.physics.sigma = L(0.45, 0.9, vE);         // broader, softer spread when hard
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', () => {
            new EggYolkVisualizer();
        });
    </script>
</body>
</html>
